name: ESP-IDF Build (Reusable)

on:
  workflow_call:
    inputs:
      project_dir:
        description: "Path to the ESP-IDF project (contains scripts/, CMakeLists.txt)"
        type: string
        required: true
      scripts_dir:
        description: "Path to nt-espidf-project-tools directory (contains scripts directly). Leave empty to auto-detect."
        type: string
        required: false
      build_path:
        description: "Staging/build workspace directory"
        type: string
        default: "ci_build_path"
      clean_build:
        description: "Skip caches for a clean build"
        type: boolean
        default: false
      auto_clone_tools:
        description: "Auto-clone tools repo if scripts_dir is missing"
        type: boolean
        default: false
      tools_repo_url:
        description: "Git URL for nt-espidf-project-tools"
        type: string
        default: "https://github.com/N3b3x/nt-espidf-project-tools.git"
      tools_repo_ref:
        description: "Branch or tag for nt-espidf-project-tools"
        type: string
        default: "main"
    secrets:
      GITHUB_TOKEN:
        required: false

permissions:
  contents: read
  actions: read
  pull-requests: write   # needed for PR comment in size-report

env:
  BUILD_PATH: ${{ inputs.build_path }}
  ESP32_PROJECT_PATH: ${{ inputs.project_dir }}
  SCRIPTS_DIR: ${{ inputs.scripts_dir }}

jobs:
  generate-matrix:
    name: Generate Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.gen.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with: { submodules: recursive }

      - name: Ensure tools directory present
        if: ${{ inputs.auto_clone_tools }}
        run: |
          if [ ! -d "${{ env.SCRIPTS_DIR }}" ]; then
            echo "Cloning tools repo to ${{ env.SCRIPTS_DIR }}"
            git clone --depth 1 --branch "${{ inputs.tools_repo_ref }}" \
              "${{ inputs.tools_repo_url }}" "${{ env.SCRIPTS_DIR }}"
          else
            echo "Tools directory exists: ${{ env.SCRIPTS_DIR }}"
          fi

      - uses: actions/setup-python@v5
        with: { python-version: '3.x' }

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml jq

      - name: Generate matrix
        id: gen
        run: |
          set -e
          MATRIX=$(python3 "${{ env.SCRIPTS_DIR }}/generate_matrix.py")
          echo "matrix=${MATRIX}" >> "$GITHUB_OUTPUT"
          echo "$MATRIX" | python3 -m json.tool

  build:
    name: Build âžœ ${{ matrix.idf_version }} Â· ${{ matrix.build_type }} Â· ${{ matrix.app_name }}
    runs-on: ubuntu-latest
    needs: generate-matrix
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4
        with: { submodules: recursive }

      - name: Cache Python deps (for project scripts)
        if: ${{ !inputs.clean_build }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python3.*/site-packages
          key: >-
            espidf-python-${{ runner.os }}-${{ matrix.idf_version_docker }}-
            ${{ hashFiles(format('{0}/scripts/setup_common.sh', env.ESP32_PROJECT_PATH),
                          format('{0}/scripts/requirements.txt', env.ESP32_PROJECT_PATH)) }}
          restore-keys: |
            espidf-python-${{ runner.os }}-

      - name: Install Python deps (optional)
        run: |
          # Determine scripts path - use SCRIPTS_DIR if specified, otherwise look for nt-espidf-project-tools
          if [ -n "${{ env.SCRIPTS_DIR }}" ]; then
              SCRIPTS_PATH="${{ env.SCRIPTS_DIR }}"
          else
              # Look for scripts in project directory first
              if [ -d "${ESP32_PROJECT_PATH}/nt-espidf-project-tools" ]; then
                  SCRIPTS_PATH="${ESP32_PROJECT_PATH}/nt-espidf-project-tools"
              else
                  # Fallback to auto-cloned location
                  SCRIPTS_PATH="nt-espidf-project-tools"
              fi
          fi
          
          if [ -f "${SCRIPTS_PATH}/requirements.txt" ]; then
            python -m pip install --upgrade pip
            pip install -r "${SCRIPTS_PATH}/requirements.txt"
          fi

      # NOTE: when used as a reusable workflow, reference the composite action in this repo, not a local path in the consumer
      - name: Prepare CI workspace (setup_ci.sh)
        uses: N3b3x/hf-espidf-ci-tools/.github/actions/setup-ci-build@v1
        with:
          project-path: ${{ env.ESP32_PROJECT_PATH }}
          build-dir: ${{ env.BUILD_PATH }}
          # if you added script-path input to the composite, you can pass it here:
          # script-path: ${{ env.SCRIPTS_DIR }}/setup_ci.sh

      - name: Cache ccache
        if: ${{ !inputs.clean_build }}
        id: ccache
        uses: actions/cache@v4
        with:
          path: ~/.ccache
          key: >-
            espidf-ccache-${{ runner.os }}-${{ matrix.idf_version_docker }}-${{ matrix.build_type }}-
            ${{ hashFiles('src/**','inc/**','examples/**') }}
          restore-keys: |
            espidf-ccache-${{ runner.os }}-${{ matrix.idf_version_docker }}-
            espidf-ccache-${{ runner.os }}-

      - name: Build (espressif/esp-idf-ci-action)
        id: build
        uses: espressif/esp-idf-ci-action@v1
        with:
          esp_idf_version: ${{ matrix.idf_version_docker }}
          target: ${{ matrix.target }}
          path: .
          extra_docker_args: >-
            -v $HOME/.ccache:/root/.ccache
            -e CCACHE_DIR=/root/.ccache
            -e IDF_CCACHE_ENABLE=1
          command: |
            set -e
            export BUILD_PATH="${{ env.BUILD_PATH }}"
            export ESP32_PROJECT_PATH="${{ env.ESP32_PROJECT_PATH }}"
            export IDF_TARGET="${{ matrix.target }}"
            export BUILD_TYPE="${{ matrix.build_type }}"
            export APP_TYPE="${{ matrix.app_name }}"

            cd "${BUILD_PATH}"
            # Determine scripts path - use SCRIPTS_DIR if specified, otherwise look for nt-espidf-project-tools
            if [ -n "${{ env.SCRIPTS_DIR }}" ]; then
                SCRIPTS_PATH="${{ env.SCRIPTS_DIR }}"
            else
                # Look for scripts in project directory first
                if [ -d "${ESP32_PROJECT_PATH}/nt-espidf-project-tools" ]; then
                    SCRIPTS_PATH="${ESP32_PROJECT_PATH}/nt-espidf-project-tools"
                else
                    # Fallback to auto-cloned location
                    SCRIPTS_PATH="nt-espidf-project-tools"
                fi
            fi
            
            # Run build script with correct paths
            "${SCRIPTS_PATH}/build_app.sh" --project-path "${ESP32_PROJECT_PATH}" "${APP_TYPE}" "${BUILD_TYPE}" "${{ matrix.idf_version }}"
            build_dir=$(ls -td build*/ 2>/dev/null | head -1)
            [ -z "$build_dir" ] && { echo "No build dir!"; exit 1; }
            echo "build_dir=${build_dir%/}" >> "$GITHUB_OUTPUT"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: fw-${{ matrix.app_name }}-${{ matrix.idf_version }}-${{ matrix.build_type }}
          path: ${{ env.BUILD_PATH }}/${{ steps.build.outputs.build_dir }}
          retention-days: 7

  # --- NEW: PR size summary inside the same reusable workflow ---
  size-report:
    name: Firmware Size Report
    if: github.event_name == 'pull_request'
    needs: [build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all firmware artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: fw-*
          merge-multiple: true
          path: fw_artifacts/

      - name: Build markdown summary
        id: mk
        shell: bash
        run: |
          set -euo pipefail
          OUT="size-summary.md"
          echo "## ðŸ“¦ Firmware Size Summary" > "$OUT"
          echo "" >> "$OUT"
          echo "| App | IDF | Target | Build | Flash/RAM summary |" >> "$OUT"
          echo "|---|---|---|---|---|" >> "$OUT"

          found=0
          shopt -s nullglob
          # Preferred: use size.info (written by build_app.sh)
          while IFS= read -r -d '' info; do
            dir="$(dirname "$info")"
            app=$(grep -E '^APP='    "$info" | cut -d= -f2- || echo "-")
            idf=$(grep -E '^IDF='    "$info" | cut -d= -f2- || echo "-")
            tgt=$(grep -E '^TARGET=' "$info" | cut -d= -f2- || echo "-")
            bld=$(grep -E '^BUILD='  "$info" | cut -d= -f2- || echo "-")

            if [[ -f "$dir/size.txt" ]]; then
              summary="$(grep -E 'Total|text\s+data\s+bss' "$dir/size.txt" | head -2 \
                        | tr -s ' ' ' ' | sed 's/^/`/;s/$/`/' | paste -sd '<br/>' -)"
            else
              summary="`size.txt missing`"
            fi

            echo "| $app | $idf | $tgt | $bld | ${summary:-\`See size.txt\`} |" >> "$OUT"
            found=$((found+1))
          done < <(find fw_artifacts -type f -name "size.info" -print0)

          # Fallback: if no size.info available, scan for size.txt
          if [[ $found -eq 0 ]]; then
            while IFS= read -r -d '' st; do
              dir="$(dirname "$st")"
              parent="$(basename "$dir")"
              app="$(echo "$parent" | sed -E 's/^build_([^_]+).*/\1/')" || app="-"
              idf="-"; tgt="-"; bld="$(echo "$parent" | grep -Eo '(Debug|Release)' || echo '-')"
              summary="$(grep -E 'Total|text\s+data\s+bss' "$st" | head -2 \
                         | tr -s ' ' ' ' | sed 's/^/`/;s/$/`/' | paste -sd '<br/>' -)"
              echo "| $app | $idf | $tgt | $bld | ${summary:-\`See size.txt\`} |" >> "$OUT"
              found=$((found+1))
            done < <(find fw_artifacts -type f -name "size.txt" -print0)
          fi

          if [[ $found -eq 0 ]]; then
            echo "_No size artifacts found. Ensure build_app.sh writes size.txt/size.info inside build dirs._" >> "$OUT"
          fi

          echo "file=$OUT" >> "$GITHUB_OUTPUT"

      - name: Comment summary on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('${{ steps.mk.outputs.file }}', 'utf8');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });

      # Optional guardrail: fail if size exceeds your budget
      - name: Enforce size budgets (optional)
        if: always()
        shell: bash
        env:
          MAX_DEC_TOTAL: "1600000"   # example combined dec (text+data+bss) threshold in bytes
        run: |
          set -euo pipefail
          vio=0
          while IFS= read -r -d '' st; do
            dec=$(grep -E '^\s*text\s+data\s+bss\s+dec' -A1 "$st" | tail -1 | awk '{print $4}' || echo 0)
            dir="$(dirname "$st")"
            if [[ "${dec:-0}" -gt "$MAX_DEC_TOTAL" ]]; then
              echo "::error file=${st}::${dir} dec=${dec} exceeds MAX_DEC_TOTAL=${MAX_DEC_TOTAL}"
              vio=$((vio+1))
            fi
          done < <(find fw_artifacts -type f -name "size.txt" -print0)
          [[ $vio -gt 0 ]] && exit 1 || exit 0
